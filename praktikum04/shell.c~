#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>

#include "alloc.h"
#include "shell.h"

/* shell.c
Hauptdatei fuer eigene Shell.

Autoren: Timo Graw, Marcel Teuber

Version: 0.1 - start
*/

char *user;
char *pwd;

int main (int argc, char *argv[], char *env[]) {

	int prompt_errno;

	user = getenv_malloc("USER");
	
	while ((prompt_errno = prompt()) == 0);

	if (prompt_errno != RET_EXIT)
		return prompt_errno;
	else
		return 0;
}


int prompt() {
	
	char input_string[INPUTLINEBUFFER_LENGTH];
	
	free(pwd);
	/* Current Working Directory ermitteln */
	pwd = getcwd(NULL, PATH_BUFFERLENGTH);
	
	/* Prompt ausgabe (farbig) */
	printf("\E[32;40m%s:\E[31;40m%s\E[0m>", user, pwd);

	fgets(input_string, INPUTLINEBUFFER_LENGTH, stdin);

	/* newline character entfernen wenn vorhanden */
	if (input_string[strlen(input_string)-1] == '\n')
		input_string[strlen(input_string)-1] = '\0';

	/* check exit & cd */
	if (strcmp(input_string, "exit") == 0)
		return RET_EXIT;
	else if (strncmp(input_string, "cd", 2) == 0) {
		change_directory(input_string);
	}
	else {
		fork_process(input_string);
	}
	
	return 0;
}

int change_directory(char *directory_string) {
	int err;
	char *cd_param;
	
	if (!strtok(directory_string, " ") || !(cd_param = strtok_malloc(NULL, " "))) {
		return -1;
	}
	
	err = chdir(cd_param);
	if (err)
		perror("change_directory()");
	return err;
}

int fork_process(char *input_string) {
	int pid;
	int stat_loc;

	pid = fork();
	
	if (pid == -1) {
		/* Fork fehlgeschlagen! */
		perror("fork_process()");
		return errno;
	}
	else if (pid == 0) {
		/* Child Process */
		exit(handle_command(input_string));
	}
	else {
		/* Parent Process */
		waitpid(pid, &stat_loc, 0);
		
		if (!WIFEXITED(stat_loc)) {
			printf("Kindprozess wurde nicht normal beendet\n");
		}
	}
	
	return 0; 
}

int handle_command(char *command_string) {
	char *path;
	char *parameters[PARAMETERS_MAX];
	int parameter_count;
	
	parameter_count = parse_parameters(command_string, parameters);
	
	path = parameters[0];
	
	execute_command(path, parameters);
	
	/* Speicher freigeben */
	for (; parameter_count < 0; parameter_count--)
		free(parameters[parameter_count]);
	free(path);
	
	return 0;
}

int parse_parameters(char *command_string, char *parameters[PARAMETERS_MAX]) {
	int n, i;
	
	parameters[0] = strtok_malloc(command_string, " ");
	resolve_parameter(&parameters[0]);
	
	n = 0;
	do {
		n++;
		parameters[n] = strtok_malloc(NULL, " ");
	} while (parameters[n] != NULL);
	
	for (i = 0; i < n; i++)
		resolve_parameter(&parameters[i]);
	
	return i;
}


int execute_command(char *path, char *parameters[PARAMETERS_MAX]) {
	int err;
	
	#ifdef DEBUG
	int i = 0;
	while (parameters[i]) {
		printf ("Parameter %i = %s\n", i, parameters[i]);
		i++;
	};
	#endif
	
	err = execvp(path, parameters);
	
	if (err)
		perror("execvp()");
	
	return err;
}

int resolve_parameter(char **parameter) {
	char *tmp_ptr;
	
	if (*parameter == NULL) {
		#ifdef DEBUG
		printf("resolve_parameters(): Nullpointer uebergeben\n");
		#endif
		return -1;
	}
	
	/* Erstes Zeichen ist Variablenmakierung */
	if (*parameter[0] == '$') {
		/* Entsprechenden Variablenwert ermitteln */
		tmp_ptr = strtok(*parameter, "$");
		tmp_ptr = getenv_malloc(tmp_ptr);
		
		free(*parameter);
		
		*parameter = tmp_ptr;
		return 1;
	}
	else
		return 0;
}


